@using MineSweeper.Services
@inject GameService GameService
@inject SoundService SoundService
@implements IDisposable

<style>
    /* ===== GAME CELLS ===== */
    .cell-button {
        border-radius: 0.25rem;
        transition: transform 100ms ease-out;
        transform: scale(1);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 0.875rem;
        width: 1.75rem;
        height: 1.75rem;
        will-change: transform;
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
    }

    @@media (min-width: 768px) {
        .cell-button {
            font-size: 1rem;
            width: 2rem;
            height: 2rem;
        }
    }

    .cell-button:not(:disabled):hover {
        transform: scale(1.1);
    }

    .cell-unrevealed {
        background: linear-gradient(to bottom right, #4b5563, #374151);
        border: 2px solid #6b7280;
        box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
    }

    .cell-unrevealed:not(:disabled):hover {
        background: linear-gradient(to bottom right, #6b7280, #4b5563);
    }

    .cell-mine {
        background: linear-gradient(to bottom right, #dc2626, #b91c1c);
        border: 2px solid #991b1b;
        animation: mine-reveal 0.5s ease-out;
    }

    @@keyframes mine-reveal {
        0% {
            transform: scale(0) rotate(180deg);
        }
        50% {
            transform: scale(1.2) rotate(90deg);
        }
        100% {
            transform: scale(1) rotate(0deg);
        }
    }

    .cell-revealed {
        background-color: #1f2937;
        border: 1px solid #374151;
        box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
        animation: cell-reveal 0.15s ease-out;
    }

    @@keyframes cell-reveal {
        0% {
            transform: scale(0.95);
            opacity: 0.7;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    /* Number colors */
    .mine-count-1 { color: #60a5fa; }
    .mine-count-2 { color: #34d399; }
    .mine-count-3 { color: #f87171; }
    .mine-count-4 { color: #a78bfa; }
    .mine-count-5 { color: #fbbf24; }
    .mine-count-6 { color: #f472b6; }
    .mine-count-7 { color: #d1d5db; }
    .mine-count-8 { color: #f3f4f6; }

    /* ===== GAME BOARD ===== */
    .game-board {
        display: inline-grid;
        gap: 0.125rem;
        padding: 1rem;
        background-color: #111827;
        border-radius: 0.75rem;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    }

    .game-over-overlay {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 0.75rem;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
        animation: fade-in 0.3s ease-out;
    }

    .game-over-content {
        background-color: #1f2937;
        padding: 2rem;
        border-radius: 1rem;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        text-align: center;
        transform: scale(1.1);
        animation: bounce-in 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    @@keyframes bounce-in {
        0% {
            transform: scale(0);
            opacity: 0;
        }
        50% {
            transform: scale(1.1);
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    /* ===== FLAGS ===== */
    .flag-animation {
        animation: flag-place 0.3s ease-out;
    }

    @@keyframes flag-place {
        0% {
            transform: scale(0) rotate(-180deg);
        }
        50% {
            transform: scale(1.2) rotate(-90deg);
        }
        100% {
            transform: scale(1) rotate(0deg);
        }
    }

    @@keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    /* ===== RESPONSIVE GRID ===== */
    @@media (max-width: 640px) {
        .game-board {
            gap: 0.125rem;
            padding: 0.5rem;
        }

        .cell-button {
            width: 1.5rem;
            height: 1.5rem;
            font-size: 0.75rem;
        }
    }
</style>

@if (GameService.CurrentGame != null)
{
    <div class="relative">
        <div class="overflow-auto max-h-[70vh] rounded-xl shadow-2xl">
            <div class="game-board" 
                 style="grid-template-columns: repeat(@GameService.CurrentGame.Columns, minmax(0, 1fr));">
                @for (int row = 0; row < GameService.CurrentGame.Rows; row++)
                {
                    @for (int col = 0; col < GameService.CurrentGame.Columns; col++)
                    {
                        var r = row;
                        var c = col;
                        var cell = GameService.CurrentGame.Board[r, c];
                        
                        <button @key="@(r * GameService.CurrentGame.Columns + c)"
                                @onclick="(e) => HandleCellClick(r, c, e)"
                                @oncontextmenu="(e) => HandleRightClick(r, c, e)"
                                @oncontextmenu:preventDefault="true"
                                @ondblclick="() => HandleDoubleClick(r, c)"
                                class="cell-button @GetCellClass(cell)"
                                disabled="@(GameService.CurrentGame.Status != GameStatus.InProgress && GameService.CurrentGame.Status != GameStatus.NotStarted)"
                                id="cell-@r-@c">
                            <span class="@(cell.IsFlagged && !cell.IsRevealed ? "flag-animation" : "")">
                                @GetCellContent(cell)
                            </span>
                        </button>
                    }
                }
            </div>
        </div>
        
        @if (GameService.CurrentGame != null && 
             GameService.CurrentGame.CreatedAt == _currentGameCreatedAt &&
             (GameService.CurrentGame.Status == GameStatus.Won || GameService.CurrentGame.Status == GameStatus.Lost))
        {
            <div class="game-over-overlay">
                <div class="game-over-content">
                    @if (GameService.CurrentGame.Status == GameStatus.Won)
                    {
                        <div class="animate-bounce">
                            <p class="text-4xl font-bold text-green-400 mb-2">Victory! ðŸŽ‰</p>
                            <p class="text-xl text-white">Time: @FormatTime(GameService.CurrentGame.ElapsedTime)</p>
                            <p class="text-sm text-gray-400 mt-2">You found all mines!</p>
                        </div>
                    }
                    else
                    {
                        <div class="animate-pulse">
                            <p class="text-4xl font-bold text-red-400 mb-2">Game Over ðŸ’¥</p>
                            <p class="text-lg text-white">Better luck next time!</p>
                        </div>
                    }
                </div>
            </div>
        }
    </div>
}

@code {
    [Inject] private IJSRuntime JSRuntime { get; set; } = default!;
    
    private DateTime _currentGameCreatedAt = DateTime.MinValue;
    
    protected override void OnInitialized()
    {
        GameService.OnGameStateChanged += OnGameStateChanged;
        if (GameService.CurrentGame != null)
        {
            _currentGameCreatedAt = GameService.CurrentGame.CreatedAt;
        }
    }
    
    protected override void OnParametersSet()
    {
        // Update the current game reference when parameters change
        if (GameService.CurrentGame != null && GameService.CurrentGame.CreatedAt != _currentGameCreatedAt)
        {
            _currentGameCreatedAt = GameService.CurrentGame.CreatedAt;
            _hasPlayedWinEffect = false;
        }
    }
    
    private void OnGameStateChanged()
    {
        // Update the current game reference
        if (GameService.CurrentGame != null)
        {
            _currentGameCreatedAt = GameService.CurrentGame.CreatedAt;
        }
        InvokeAsync(StateHasChanged);
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("ParticleEffects.init");
        }
        
        // Check for game over states and trigger effects
        if (GameService.CurrentGame != null)
        {
            if (GameService.CurrentGame.Status == GameStatus.Won && !_hasPlayedWinEffect)
            {
                _hasPlayedWinEffect = true;
                await JSRuntime.InvokeVoidAsync("ParticleEffects.createConfetti");
            }
            else if (GameService.CurrentGame.Status == GameStatus.InProgress || GameService.CurrentGame.Status == GameStatus.NotStarted)
            {
                _hasPlayedWinEffect = false;
            }
        }
    }
    
    private bool _hasPlayedWinEffect = false;
    
    private async void HandleCellClick(int row, int col, MouseEventArgs e)
    {
        var previousStatus = GameService.CurrentGame?.Status;
        var cell = GameService.CurrentGame?.Board[row, col];
        var wasMine = cell?.IsMine ?? false;
        var wasRevealed = cell?.IsRevealed ?? false;
        
        GameService.RevealCell(row, col);
        
        if (GameService.CurrentGame?.Status == GameStatus.InProgress || 
            (previousStatus == GameStatus.NotStarted && GameService.CurrentGame?.Status == GameStatus.InProgress))
        {
            await SoundService.PlayClickAsync();
            
            // Only add sparkle effect for single cell reveals (not batch reveals)
            if (!wasMine && !wasRevealed && GameService.CurrentGame?.Status == GameStatus.InProgress)
            {
                var newCell = GameService.CurrentGame?.Board[row, col];
                if (newCell != null && newCell.AdjacentMines > 0)
                {
                    // Only sparkle for cells with numbers (not empty cells that trigger batch reveal)
                    await JSRuntime.InvokeVoidAsync("ParticleEffects.createSparkle", e.ClientX, e.ClientY);
                }
            }
        }
        
        // Add explosion effect if mine was hit
        if (wasMine && GameService.CurrentGame?.Status == GameStatus.Lost)
        {
            await JSRuntime.InvokeVoidAsync("ParticleEffects.createExplosion", e.ClientX, e.ClientY);
        }
    }
    
    private async void HandleRightClick(int row, int col, MouseEventArgs e)
    {
        GameService.ToggleFlag(row, col);
        await SoundService.PlayClickAsync();
    }
    
    private async void HandleDoubleClick(int row, int col)
    {
        GameService.RevealAdjacentIfSafe(row, col);
        await SoundService.PlayClickAsync();
    }
    
    private string GetCellClass(Cell cell)
    {
        if (!cell.IsRevealed)
        {
            return "cell-unrevealed";
        }
        
        if (cell.IsMine)
        {
            return "cell-mine";
        }
        
        var numberClass = cell.AdjacentMines > 0 ? $" mine-count-{cell.AdjacentMines}" : "";
        return $"cell-revealed{numberClass}";
    }
    
    private string GetCellContent(Cell cell)
    {
        if (!cell.IsRevealed && cell.IsFlagged)
        {
            return "ðŸš©";
        }
        
        if (!cell.IsRevealed)
        {
            return "";
        }
        
        if (cell.IsMine)
        {
            return "ðŸ’£";
        }
        
        return cell.AdjacentMines > 0 ? cell.AdjacentMines.ToString() : "";
    }
    
    private string FormatTime(TimeSpan time)
    {
        return $"{(int)time.TotalMinutes:00}:{time.Seconds:00}";
    }
    
    public void Dispose()
    {
        GameService.OnGameStateChanged -= OnGameStateChanged;
    }
}